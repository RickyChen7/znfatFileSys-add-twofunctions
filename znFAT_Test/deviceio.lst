C51 COMPILER V9.54   DEVICEIO                                                              05/29/2018 20:45:21 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE DEVICEIO
OBJECT MODULE PLACED IN deviceio.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE znFAT\deviceio.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\deviceio.lst) OBJECT(deviceio.obj)

line level    source

   1          #include "mytype.h"
   2          #include "config.h"
   3          #include "deviceio.h" 
   4          #include "SD.h"              // ´æ´¢Éè±¸Çı¶¯Í·ÎÄ¼ş 
   5          struct znFAT_IO_Ctl ioctl;   // ÓÃÓÚÉÈÇø¶ÁĞ´µÄIO¿ØÖÆ£¬¾¡Á¿¼õÉÙÎïÀíÉÈÇø²Ù×÷£¬Ìá¸ßĞ§ÂÊ
   6          extern UINT8 Dev_No;         // Éè±¸ºÅ
   7          extern UINT8 *znFAT_Buffer;
   8          
   9          /*******************************************************************
  10           ¹¦ÄÜ£º´æ´¢Éè±¸³õÊ¼»¯
  11           ĞÎ²Î£ºÎŞĞÎ²Î
  12           ·µ»Ø£º´æ´¢Éè±¸³õÊ¼»¯´íÎóĞÅÏ¢
  13           Ïê½â£ºznFATÖ§³Ö¶àÉè±¸£¬¼´Í¬Ê±¹Ò½Ó¶àÖÖ´æ´¢Éè±¸£¬ËùÓĞ´æ´¢Éè±¸µÄ³õÊ¼
  14                 »¯¾ùÔÚÕâÀïÍê³É¡£·µ»ØÖµµÄÄ³Ò»Î»Îª1£¬ÔòËµÃ÷ÏàÓ¦µÄ´æ´¢Éè±¸³õÊ¼
  15                 »¯Ê§°Ü¡£ÀıÈç£ºÉè±¸0Ê§°Ü£¬¶øÆäËüÉè±¸¾ù³É¹¦£¬Ôò·µ»ØÖµÎª0X01¡¢
  16                 Éè±¸1ÓëÉè±¸2Ê§°Ü£¬¶øÆäËüÉè±¸³É¹¦£¬Ôò·µ»ØÖµÎª0X06¡£ÎªÁËÊ¹·µ»Ø
  17                 ÖµÈçÊµµÄ·´Ó³ÏàÓ¦Éè±¸µÄ³õÊ¼»¯×´Ì¬£¬Çë×¢Òâ´æ´¢Éè±¸³õÊ¼»¯º¯Êı
  18                 µ÷ÓÃµÄË³Ğò¡£
  19          *******************************************************************/
  20          
  21          UINT8 znFAT_Device_Init(void) 
  22          {
  23   1              UINT8 res=0,err=0;
  24   1              
  25   1              ioctl.just_dev=0;
  26   1              ioctl.just_sec=0;
  27   1              
  28   1              //ÒÔÏÂÎª¸÷´æ´¢Éè±¸µÄ³õÊ¼»¯º¯Êıµ÷ÓÃ£¬ÇëÑØÏ®ÒÔÏÂ¸ñÊ½
  29   1              
  30   1              res=SD_Init(); 
  31   1              if(res) err|=0X01;
  32   1              
  33   1              //res=Device1_Init();
  34   1              //if(res) err|=0X02;
  35   1              
  36   1              return err; //·µ»Ø´íÎóÂë£¬Èç¹ûÄ³Ò»Éè±¸³õÊ¼»¯Ê§°Ü£¬ÔòerrÏàÓ¦Î»Îª1
  37   1      }
  38          
  39          /*****************************************************************************
  40           ¹¦ÄÜ£ºznFATµÄ´æ´¢Éè±¸ÎïÀíÉÈÇø¶ÁÈ¡Çı¶¯½Ó¿Ú
  41           ĞÎ²Î£ºaddr:ÎïÀíÉÈÇøµØÖ· buffer:Êı¾İ»º³åÇøÖ¸Õë
  42           ·µ»Ø£º0
  43           Ïê½â£º¸÷´æ´¢Éè±¸µÄÎïÀíÉÈÇø¶ÁÈ¡Çı¶¯º¯Êı·Åµ½caseµÄ¸÷¸ö·ÖÖ§ÖĞ£¬·ÖÖ§ĞòºÅ¾ÍÊÇ´ËÉè
  44                 ±¸µÄÉè±¸ºÅ¡£ 
  45          *****************************************************************************/
  46          UINT8 znFAT_Device_Read_Sector(UINT32 addr,UINT8 *buffer)
  47          {
  48   1              if(buffer==znFAT_Buffer) //Èç¹ûÊÇÕë¶ÔznFATÄÚ²¿»º³åÇøµÄ²Ù×÷
  49   1              {                        
  50   2                      if(ioctl.just_dev==Dev_No  //Èç¹ûÏÖÔÚÒª¶ÁÈ¡µÄÉÈÇøÓëÄÚ²¿»º³åËù¶ÔÓ¦µÄÉÈÇø£¨¼´×î½üÒ»´Î²Ù×÷µÄÉÈÇø£©ÊÇÍ¬Ò»ÉÈÇ
             -ø
  51   2                       && (ioctl.just_sec==addr && 0!=ioctl.just_sec)) //Ôò²»ÔÙ½øĞĞ¶ÁÈ¡£¬Ö±½Ó·µ»Ø
  52   2                      {                                           
  53   3                              return 0;      
C51 COMPILER V9.54   DEVICEIO                                                              05/29/2018 20:45:21 PAGE 2   

  54   3                      }
  55   2                      else //·ñÔò£¬¾Í½«×î½üÒ»´Î²Ù×÷µÄÉÈÇø±ê¼ÇÎªµ±Ç°ÉÈÇø
  56   2                      {
  57   3                              ioctl.just_dev=Dev_No; 
  58   3                              ioctl.just_sec=addr; 
  59   3                      }
  60   2              }
  61   1              
  62   1              switch(Dev_No) //ÓĞ¶àÉÙ¸ö´æ´¢Éè±¸£¬¾ÍÓĞ¶àÉÙ¸öcase·ÖÖ§
  63   1              {
  64   2                      case 0:
  65   2                                      while(SD_Read_Sector(addr,buffer));
  66   2                                      break;
  67   2                      //case 1:
  68   2                      //           while(SD2_Read_Sector(addr,buffer));
  69   2                      //                 break;
  70   2                      //case...
  71   2              
  72   2              }       
  73   1              return 0;
  74   1      }
  75          
  76          /*****************************************************************************
  77           ¹¦ÄÜ£ºznFATµÄ´æ´¢Éè±¸ÎïÀíÉÈÇøĞ´ÈëÇı¶¯½Ó¿Ú
  78           ĞÎ²Î£ºaddr:ÎïÀíÉÈÇøµØÖ· buffer:Êı¾İ»º³åÇøÖ¸Õë
  79           ·µ»Ø£º0
  80           Ïê½â£º¸÷´æ´¢Éè±¸µÄÎïÀíÉÈÇøĞ´ÈëÇı¶¯º¯Êı·Åµ½caseµÄ¸÷¸ö·ÖÖ§ÖĞ£¬·ÖÖ§ĞòºÅ¾ÍÊÇ´ËÉè
  81                 ±¸µÄÉè±¸ºÅ¡£ 
  82          *****************************************************************************/
  83          UINT8 znFAT_Device_Write_Sector(UINT32 addr,UINT8 *buffer) 
  84          {
  85   1              if(buffer==znFAT_Buffer) //Èç¹ûÊı¾İ»º³åÇøÊÇÄÚ²¿»º³å
  86   1              {
  87   2                      ioctl.just_dev=Dev_No; //¸üĞÂÎªµ±Ç°Éè±¸ºÅ
  88   2                      ioctl.just_sec=addr; //¸üĞÂÎªµ±Ç°²Ù×÷µÄÉÈÇøµØÖ· 
  89   2              }
  90   1              
  91   1              switch(Dev_No)
  92   1              {
  93   2                      case 0:
  94   2                                      while(SD_Write_Sector(addr,buffer));
  95   2                                      break;
  96   2                      //case 1:
  97   2                      //           while(SD2_Write_Sector(addr,buffer));
  98   2                      //                 break;
  99   2                      //case...
 100   2              
 101   2              } 
 102   1              
 103   1              return 0;
 104   1      }
 105          
 106          /***********************************************************************************
 107           ¹¦ÄÜ£ºznFATµÄ´æ´¢Éè±¸ÎïÀíÉÈÇøÁ¬Ğø¶ÁÈ¡Çı¶¯½Ó¿Ú
 108           ĞÎ²Î£ºnsec:Òª¶ÁÈ¡µÄÉÈÇøÊı addr:Á¬ĞøÉÈÇø¶ÁÈ¡Ê±µÄ¿ªÊ¼ÉÈÇøµØÖ· buffer:Êı¾İ»º³åÇøÖ¸Õë
 109           ·µ»Ø£º0
 110           Ïê½â£º´Ëº¯Êı½Ó¿ÚÔÚznFATÖĞÓÃÓÚÍê³ÉÈô¸É¸öÁ¬ĞøÉÈÇøµÄÒ»´ÎĞÔ¶ÁÈ¡¡£´Ëº¯Êı½Ó¿ÚµÄÊµÏÖÓĞÁ½ÖÖ
 111                 Ä£Ê½ 1¡¢µ¥ÉÈÇø¶ÁÈ¡Çı¶¯+Ñ­»· 2¡¢´æ´¢Éè±¸Ó²¼şÉÏµÄÁ¬ĞøÉÈÇø¶ÁÈ¡ Ê¹ÓÃ2±È1µÄĞ§ÂÊÒª
 112                 µÃ¶à£¬ÔÚ¸ßËÙÇÒÊı¾İÁ¿±È½Ï´óµÄÓ¦ÓÃ³¡ºÏ£¬½¨ÒéÊ¹ÓÃÕßÌá¹©Ó²¼ş¼¶µÄÁ¬ĞøÉÈÇø¶ÁÈ¡º¯Êı
 113          ***********************************************************************************/
 114          UINT8 znFAT_Device_Read_nSector(UINT32 nsec,UINT32 addr,UINT8 *buffer)
 115          {
C51 COMPILER V9.54   DEVICEIO                                                              05/29/2018 20:45:21 PAGE 3   

 116   1              UINT32 i=0;
 117   1              
 118   1              if(0==nsec) return 0;
 119   1              
 120   1              #ifndef USE_MULTISEC_R //´Ëºê¾ö¶¨ÊÇ·ñÊ¹ÓÃÓ²¼ş¼¶Á¬ĞøÉÈÇø¶ÁÈ¡Çı¶¯
 121   1              
 122   1              switch(Dev_No)
 123   1              {
 124   2                      case 0:
 125   2                              for(i=0;i<nsec;i++) //Èç¹û²»Ê¹ÓÃÓ²¼ş¼¶Á¬ĞøÉÈÇø¶ÁÈ¡£¬ÔòÊ¹ÓÃµ¥ÉÈÇø¶ÁÈ¡+Ñ­»·µÄ·½Ê½
 126   2                              {
 127   3                                      while(SD_Read_Sector(addr+i,buffer));
 128   3                                      buffer+=512;
 129   3                              }
 130   2                              break;
 131   2                      // case 1:
 132   2                      //       for(i=0;i<nsec;i++) //Èç¹û²»Ê¹ÓÃÓ²¼ş¼¶µÄÁ¬ĞøÉÈÇø¶ÁÈ¡£¬ÔòÊ¹ÓÃµ¥ÉÈÇø¶ÁÈ¡+Ñ­»·µÄ·½Ê½
 133   2                      //        {
 134   2                      //        while(SD2_Read_Sector(addr+i,buffer));
 135   2                      //        buffer+=512;
 136   2                      //       }
 137   2                      //        break;
 138   2              }
 139   1              
 140   1              #else
                      
                      switch(Dev_No)
                      {
                              case 0:
                                    while(SD_Read_nSector(nsec,addr,buffer));
                              //case 1:
                                    //while(Device1_Read_nSector(nsec,addr,buffer));
                      }
                      #endif
 150   1              
 151   1              return 0;
 152   1      }
 153          
 154          /***********************************************************************************
 155           ¹¦ÄÜ£ºznFATµÄ´æ´¢Éè±¸ÎïÀíÉÈÇøÁ¬ĞøĞ´ÈëÇı¶¯½Ó¿Ú
 156           ĞÎ²Î£ºnsec:ÒªĞ´ÈëµÄÉÈÇøÊı addr:Á¬ĞøÉÈÇøĞ´ÈëÊ±µÄ¿ªÊ¼ÉÈÇøµØÖ· buffer:Êı¾İ»º³åÇøÖ¸Õë
 157           ·µ»Ø£º0
 158           Ïê½â£º´Ëº¯Êı½Ó¿ÚÓëÉÏÃæµÄÁ¬Ğø¶ÁÈ¡Çı¶¯½Ó¿ÚÍ¬Àí¡£
 159          ***********************************************************************************/
 160          UINT8 znFAT_Device_Write_nSector(UINT32 nsec,UINT32 addr,UINT8 *buffer)
 161          {
 162   1              UINT32 i=0;
 163   1              
 164   1              if(0==nsec) return 0;
 165   1              
 166   1              #ifndef USE_MULTISEC_W //´Ëºê¾ö¶¨ÊÇ·ñÊ¹ÓÃÓ²¼şµÄÁ¬ĞøÉÈÇøĞ´Èëº¯Êı
 167   1              
 168   1              switch(Dev_No)
 169   1              {
 170   2                      case 0:
 171   2                                      for(i=0;i<nsec;i++)
 172   2                                      {
 173   3                                              while(SD_Write_Sector(addr+i,buffer));
 174   3                                              buffer+=512;
 175   3                                      }
 176   2                                      break;
 177   2                      //case 1:
C51 COMPILER V9.54   DEVICEIO                                                              05/29/2018 20:45:21 PAGE 4   

 178   2                      //       for(i=0;i<nsec;i++)
 179   2                      //       {
 180   2                      //        while(SD2_Write_Sector(addr+i,buffer));
 181   2                      //        buffer+=512;
 182   2                      //      }
 183   2                      //                break;
 184   2              }
 185   1              
 186   1              #else
                      
                      switch(Dev_No)
                      {
                              case 0:
                                    while(SD_Write_nSector(nsec,addr,buffer));
                                        break;
                              //case 1:
                                    //while(Device1_Write_nSector(nsec,addr,buffer));
                      }
                      
                      #endif
 198   1              
 199   1              return 0; 
 200   1      }
 201          
 202          /***********************************************************************************
 203           ¹¦ÄÜ£ºznFATµÄ´æ´¢Éè±¸ÎïÀíÉÈÇøÁ¬ĞøÇå0Çı¶¯½Ó¿Ú
 204           ĞÎ²Î£ºnsec:ÒªÇå0µÄÉÈÇøÊı addr:Á¬ĞøÉÈÇøÇå0µÄ¿ªÊ¼ÉÈÇøµØÖ·
 205           ·µ»Ø£º0
 206           Ïê½â£ºÔÚ¸ñÊ½»¯¹¦ÄÜÖĞ£¬×îºÄÊ±µÄ¾ÍÊÇ¶ÔFAT±íÉÈÇøÉÈÇøµÄÖğ¸öÇå0£¬Ê¹ÓÃÓ²¼ş¼¶µÄÁ¬ĞøÉÈÇøÇå0
 207                 Çı¶¯º¯Êı½«¿ÉÒÔºÜ´ó³Ì¶ÈÉÏ¼ÓËÙÕâÒ»¹ı³Ì¡£
 208          ***********************************************************************************/
 209          UINT8 znFAT_Device_Clear_nSector(UINT32 nsec,UINT32 addr)
 210          {
 211   1              #ifndef USE_MULTISEC_CLEAR  //´Ëºê¾ö¶¨ÊÇ·ñÊ¹ÓÃÓ²¼ş¼¶Á¬ĞøÉÈÇøÇå0º¯Êı£¬ÆäÖ÷ÒªÓÃÓÚ¸ñÊ½»¯¹ı³ÌÖĞFAT±íµÄÇå0
 212   1              UINT32 i=0;
 213   1              
 214   1              for(i=0;i<512;i++) //Çå¿ÕÄÚ²¿»º³åÇø£¬ÓÃÓÚÁ¬ĞøÉÈÇøÇå0
 215   1              {
 216   2                      znFAT_Buffer[i]=0;
 217   2              }
 218   1              
 219   1              switch(Dev_No)
 220   1              {
 221   2              case 0:
 222   2                              for(i=0;i<nsec;i++)
 223   2                              {
 224   3                                      while(SD_Write_Sector(addr+i,znFAT_Buffer));
 225   3                              }
 226   2                              break;
 227   2              //case 1:
 228   2              //       for(i=0;i<nsec;i++)
 229   2              //       {
 230   2              //       while(SD2_Write_Sector(addr+i,znFAT_Buffer));
 231   2              //       }
 232   2              //       break;
 233   2              }
 234   1              
 235   1              #else
                      
                      switch(Dev_No)
                      {
                              case 0:
C51 COMPILER V9.54   DEVICEIO                                                              05/29/2018 20:45:21 PAGE 5   

                                    return SD_Erase_nSector(nsec,addr); //ÔÚÊ¹ÓÃÓ²¼ş¼¶µÄÁ¬ĞøÉÈÇøÇå0µÄÊ±ºò£¬Çë½«Á¬ĞøÉÈÇøÇå0º¯ÊıĞ´ÔÚÕâÀï
                              //case 1:
                                    //return Device1_Clear_nSector(nsec,addr);
                      }
                      
                      #endif
 246   1              
 247   1              ioctl.just_dev=Dev_No; //¸üĞÂÎªµ±Ç°Éè±¸ºÅ
 248   1              ioctl.just_sec=(addr+nsec-1); //¸üĞÂÎªµ±Ç°²Ù×÷µÄÉÈÇøµØÖ·         
 249   1              
 250   1              return 0;  
 251   1      }
 252          
 253          //==============================¡¾ÒÔÉÏÊÇÉè±¸Çı¶¯²ã¡¿======================================================
             -==================
 254          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1085    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      5      57
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
